\section{Algoritmetyper}
Der findes mange typer algoritmer, som løser mange forskellige problemer. Vi vil i det følgende se på forskellige typer af algoritmer.
\subsection{Søgealgoritmer}
\emph{Søgealgoritmer} bruges til at løse problemer, hvor man vil finde et element, $x$, i en liste $(a_{1}, a_{2}, \dotsc, a_{n})$, eller konkludere, at $x$ ikke er i listen. Her vil løsningen være $i$, hvis $x=a_{i}$. Det er altså indekset, der er løsningen. Der findes forskellige søgealgoritmer bl.a. \emph{den lineære søgning} og \emph{den binære søgning}. Ved den lineære søgning starter man med $a_1$ og ser, om $x=a_{1}$. Hvis dette er tilfældet, er $a_{1}$'s indeks svaret, men hvis $x \neq a_{1}$, fortsætter man til $a_{2}$ og så $a_{3}$. Sådan fortsætter man, indtil man finder et element i listen, der er lig $x$, hvis et sådant element eksisterer. Hvis dette er tilfældet, returnerer algoritmen elementets indeks og ellers returnerer den 0. \autoref{alg:lineaer} illustrerer et eksempel på en lineær søgealgoritme:

\begin{algorithm}[H] 
\caption{Den lineære søgealgoritme}
\begin{algorithmic}[1]

\Procedure{lineær søgning($x$: heltal, $a_{1},a_{2},\dotsc,a_{n}$: Heltal i listen)}{}
    \State $i:=1$
    \While{$i \leq n$ \textbf{and} $x \neq a_{i}$}
        \State $i:=i+1$
    \EndWhile
    \If{$i \leq n$} 
    \State \textbf{return} $lokation:=i$
    \Else
    \State \textbf{return} $lokation:=0$
    \EndIf
  \label{roy's loop}
\EndProcedure

\end{algorithmic}
\label{alg:lineaer}
\end{algorithm}


Modsat den lineære søgning kan den binære søgning kun bruges, når en liste er \emph{ordnet}. Det vil sige, hvis listen fx er voksende, aftagende eller alfabetisk, altså $(a_{1}<a_{2}<\dotsb<a_{n})$. Den binære søgealgoritme finder nu midten af listen, $a_{m}$, hvor $m=\left \lfloor \frac{n+1}{2} \right \rfloor$. $\lfloor \ \rfloor$ er flooroperatoren, der runder ned til første heltal. Vi ser nu, hvilken side det, vi søger, er på. Hvis $a_{m}<x$, tager vi halvdelen af listen, der er større end $a_{m}$ dvs: $(a_{m+1}, a_{m+2},\dotsc,a_{n})$. Ellers tager vi halvdelen mindre end og lig $a_{m}$: $(a_{1}, a_{2},\dotsc,a_{m})$. Når vi har vurderet hvilken side af midten, den værdi, vi søger, er på, deles denne halvdel på midten, hvorefter man igen skal vurdere, hvilken side man skal arbejde videre med. Dette fortsættes, indtil tallet er fundet. Den binære søgealgoritme er illustreret i \autoref{alg:binaer}.

\begin{algorithm}[H]
\caption{Den binære søgealgoritme}
\begin{algorithmic}[1]

\Procedure{binær søgning($x$: heltal, $a_{1},a_{2},\dotsc,a_{n}$: Voksende heltal i listen)}{}
    \State $i:=1$, \{$i$ er venstre endepunkt i søgeintervallet\}
    \State $j:=n$, \{$j$ er højre endepunkt i søgeintervallet\}
    \While{$i<j$}
        \State $m=\lfloor (i+j)/2 \rfloor$
    		\If{$x>a_{m}$}
    		\State $i:=m+1$
    		\Else
    		\State $j:=m$
    		\EndIf    
    \EndWhile
    \If {$x=a_{i}$}
    	\State \textbf{return} $lokation:=i$
    \Else
    	\State \textbf{return} $lokation:=0$
    \EndIf
  \label{roy's loop}
\EndProcedure

\end{algorithmic}
\label{alg:binaer}
\end{algorithm}

\subsection{Sorteringsalgoritmer} \label{kap:sortering}
Når vi arbejder med \emph{sorteringsalgoritmer}, er det, fordi vi ønsker at sortere en liste, således at den inddeles i fx voksende rækkefølge eller alfabetisk orden. Ligesom ved søgealgoritmerne er der flere forskellige sorteringsalgoritmer. Eksempler på disse er \emph{bubblesortering} og \emph{indskudssortering}. Bubblesortering er en af de simpleste sorteringsalgoritmer, men den er ikke så effektiv. Den sammenligner tilstødende værdier i en liste og bytter om på dem, hvis rækkefølgen ikke er korrekt. Vi vil komme ind på algoritmers effektivitet i \autoref{kap:kompleksitet}.

\begin{algorithm}[H]
\caption{Bubblesorteringsalgoritmen}
\begin{algorithmic}[1]

\Procedure{bubblesortering($a_{1},a_{2},\dotsc,a_{n}$: Reelle tal hvor $n \geq 2$)}{}
\EndProcedure
\For {$i:=1$ \textbf{to} $n-1$}
    	\For {$j:=1$ \textbf{to} $n-i$}
    		\If {$a_{j}>a_{j+1}$}
    			\State Ombyt $a_{j}$ og $a_{j+1}$ 	
\EndIf
\EndFor
\EndFor
\State $a_{1},a_{2},\dotsc,a_{n}$ er i voksende rækkefølge. 

\end{algorithmic}
\end{algorithm}

\input{incl/main/algoritmer/bubble.eks}

Indskudssortering er på samme måde som bubblesortering simpel og til tider ineffektiv. For denne algoritme gælder det, at man starter med den anden værdi i listen, som sammenlignes med den første værdi. Disse to sorteres nu efter størrelse. Den tredje værdi i listen sammenlignes derefter med den første. Hvis den er større, sammenlignes den med den anden værdi i listen, og på den måde sorteres hele rækken, så de til sidst står i rækkefølge.

\begin{algorithm}[H]
\caption{Indskudssorteringsalgoritmen}
\begin{algorithmic}[1]

\Procedure{indskudssortering($a_{1},a_{2},\dotsc,a_{n}$: Reelle tal hvor $n \geq 2$)}{}
\EndProcedure
\For {$j:=2$ \textbf{to} $n$}
	\State $i:=1$
    	\While {$a_{j}>a_{i}$}
    		\State $i:=i+1$
    	\EndWhile
    	\State $m:=a_{j}$
    	\For {$k:=0$ \textbf{to} $j-i-1$}
    		\State $a_{j-k}:=a_{j-k-1}$
    	\EndFor
    	\State $a_{i}:=m$
\EndFor
\State $a_{1},a_{2},\dotsc,a_{n}$ er i voksende rækkefølge. 

\end{algorithmic}
\end{algorithm}

\input{incl/main/algoritmer/input.eks}