\section{Basisproblemet som algoritme}
For at løse vores basisproblem, ønsker vi at opstille en algoritme, som kan finde den vej gennem grafen, der giver den største profit. Vores algoritme vil tage udgangspunkt i \autoref{alg:dijkstra}. Vi deler vores kode op i mindre dele, for at give et bedre overblik og for bedre at kunne forklare de enkelte dele. Vi starter med at opskrive de givne data. 

\lstinputlisting[
  firstline=12,
  lastline=33,
  label={code:data_basis},
  caption={Definering af data for basisproblemet.}
]{code/dijkstras.py}

Værdierne er alle givet i basisproblemet. Vi har skrevet de statiske værdier som lister, da de ikke er statiske i det udvidede problem, og vi ønskede at tilpasse funktionerne, så de kunne håndtere både basisproblemet og det udvidede problem uden at skulle ændres. 

Derefter vil vi opstille en repræsentation for grafen. Dette gør vi ved at lave en funktion, der danner en dictionary med alle nabolister. Først er vi dog nødt til at lave en funktion som kan tilføje kanterne, da vi skal bruge denne i funktionen:

\lstinputlisting[
  firstline=60,
  lastline=64,
  label={code:add_edge},
  caption={Tilføjer kanter.}
]{code/dijkstras.py}

\autoref{code:add_edge} tjekker først om der er en dictionary, $u$, i en anden dictionary, $graph$. Hvis dette er tilfældet tilføjer den $v$ og kantvægten mellem $u$ og $v$ til  $u$' dictionary. Hvis $u$ ikke allerede er i $graph$, så laver den en ny dictionary til $u$ og indsætter $v$ og kantvægten mellem $u$ og $v$ i den nye dictionary.

Nu kan vi lave en funktion, der opstiller vores dictionary med nabolister:

\lstinputlisting[
  firstline=67,
  lastline=95,
  label={code:graph_dict},
  caption={Laver en dictionary med nabolister.}
]{code/dijkstras.py}

I \autoref{code:graph_dict} definerer vi en funktion som bygger en dictionary, som er fyldt med andre dictionaries. Funktionen danner først en "default dictionary" som de andre dictionaries vil blive sat ind i.
Den danner nu en flerdimensionelt liste med alle punkterne i grafen. Punkterne har navn på form $'q\textrm{x.y}'$ hvor x beskriver hvilken tid vi er i og y beskriver beholdningen. Det vil sige $'q\textrm{q3.4}'$ betyder vi efter tre måneder har en beholdning på fire enheder. Hver x-værdi har sin egen liste, det vil sige alle $'q\textrm{3.y}'$ er i en liste for sig selv.

Nu skal vi tilføje alle kanterne i grafen. Der er to specifikke tilfælde som ikke går igen, nemlig ved startpunktet og ved slutpunktet. Ved tiden $t=0$, hvor $t=i$, i denne løkke, er der nemlig kun et punkt der har kanter. Funktionen generer nu de kanterne som $'q\textrm{0.5}'$ har, og laver en dictionary for $'q\textrm{3.y}'$ 
Denne dictionary ser ud således:

\begin{lstlisting}[label=code:q05, caption=Dictionary for $q \textrm{0.5}$]

'q0.5' : {'q1.1' : 170.27, 'q1.2' : 190.2, 'q1.3' : 210.13, 'q1.4' : 230.07, 'q1.5' : 250, 'q1.6': 269.93, 'q1.7' : 289.87, 'q1.8' : 309.8, 'q1.9' : 329.73}
\end{lstlisting}
Denne dictionary viser $'q\textrm{0.5}'$s naboer og vægten på kanterne mellem dem. Alle kantvægtene er ganget med -1 for at bruge dijkstras algoritme. Derudover er der lagt 250 til alle kantvægte, så ingen af kanterne har negativ vægt, da dijkstras ikke kan bruge negative vægte.

I \autoref{code:graph_dict} ser vi, at når $i=12$ har vi også et specielt tilfælde. Dette er vores sidste værdi for $\textrm{t}$. I aftalen står der, at udlejeren køber alt gas som er tilbage når lejeperioden er ovre.   Mængden af gas vi kan sælge er altså ikke bundet af $\textrm{u\_max}$ og $\textrm{i\_max}$. I denne del af funktionen ser vi også indførslen af '$q\textrm{\_goal}$'. Dette er en værdi som kun har betydning i udvidelsen af problemet. Den beregner  en kantværdi for alle '$q\textrm{12.y}$' til '$q\textrm{\_end}$', og hvis '$q\textrm{12.y}$' ikke er lig vores '$q\textrm{\_goal}$', vil deres kantvægt til '$q\textrm{\_end}$' blive divideret med en straffaktor. I basis problemet har vi, at straffaktoren er $\kappa=1$ da vi ikke har nogle aftalt slutbeholdning og '$q\textrm{\_goal}$'.

Vi kan nu kigge på alle andre tilfælde for i. funktionen kører en løkke for $k$ med værdier mellem '$qq\textrm{\_min}$' til den specifikke tid, og '$q\textrm{\_max}$' i den specifikke tid. Dette betegner den som de nuværende enheder.
Den finder nu de største ændinger når man har $k$ enheder. Den kører derefter en løkke for $\textrm{j}$ med disse værdier, og tilføjer alle de mulige naboer til knuden i tiden $t=i$ og med beholdningen $k$. Denne del af funktionen danner således dictionaries til alle de resterende knuder i grafen på samme form som \autoref{code:q05}.

Til allersidst tilføjer den en kant mellem '$q\textrm{\_end}$' og $'\textrm{q12.0}'$ med vægt $0$, dette skyldes, at vores kode for dijkstras ikke kan finde længden til et punkt, som ikke har sin egen dictionary.

Nu har vi en dictionary med alle punkternes nabolister og alle kantvægtene. Derfor kan vi nu opstille en funktion, der ved hjælp af Dijkstras algoritme kan beregne den vej, der giver den største profit:

\lstinputlisting[
  firstline=99,
  lastline=130,
  label={code:dijkstras_optimering},
  caption={Dikstras algoritme til løsning af problemet.}
]{code/dijkstras.py}

I funktionen defineres først to tomme ordbøger. I $shortest\_distance$ opbevares den korteste vej til alle punkterne i grafen. I $predecesor$ opbevares for hvert punkt i grafen, det forrige punkt i den korteste vej, altså det punkt man går igennem lige inden man når det nye punkt, hvis man følger den korteste vej. Herefter oprettes $unseen\_nodes$ som vi sætter lig med $graph$. Dette skyldes at vi endnu ikke kender distancen til nogen af punkterne, og derfor er alle $unseen$. Vi opretter også en tom liste, som vi kalder $path$. I denne liste tilføjes de punkter som indgår i den optimale vej.\\
Vi sætter nu den korteste vej til alle punkter i $unseen\_nodes$, hvilken lige nu er alle punkterne, lig med uendelig. Dette gøres fordi der i Dijkstras algoritme er uendeligt langt til de punkter, man ikke kender længden til endnu. Da vi starter i startpunktet kan vi dog sætte den korteste vej hertil lig med nul, da vi allerede befinder os her.
Nu opstiller vi en while løkke og lader den køre så længe at der stadig er punkter i $unseen\_nodes$, altså indtil den korteste vej til alle punkter er fundet.
Vi sætter den korteste distance til et punkt lig nul, og laver derefter en for-statement. Denne statement gælder for alle punkter i $unseen\_nodes$. Hvis der ikke er fundet en midlertidig korteste vej til et punkt bliver der oprettet en midlertidig korteste vej til et punkt, og dette punkt defineres som $min\_distance\_node$, som er punktet med kortest afstand til. Hvis der allerede er defineret et punkt, som det punkt med den korteste vej til, men der findes en vej til et andet punkt, som er endnu kortere opdateres $min\_distance\_node$ til at være dette punkt.
Nu danner vi en ny for-løkke som skal betragte de mulige veje fra vores punkt.
Først tjekker den om, der eksisterer en \emph{child\_node} til punktet. Altså om punktet fører hen til andre punkter. Hvis $child\_node$ ikke har nogle kanter, sker der intet, og for-løkken går videre til næste punkt. Dette skyldes at algoritmen vil skrive fejl, hvis den forsøger at tilgå en knude som ikke har sin egen dictionary. Dette er dog kun relevant i det udvidede problem.
Hvis en $child\_node$, til  $min\_distance\_node$, derimod har minimum en kant til en anden knude, sammenligner den, om den korteste distance til $min\_distance\_node$ plus en kantvægt på en af de kanter, der ledes fra punktet, er mindre end den korteste vej til det punkt hvor kanten ledes hen, vores såkaldte $child\_node$. Hvis dette er tilfældet opdaterer vi den korteste vej til $child\_note$, da dette nu er den korteste vej. På samme måde opdaterer vi vores predecessor, da punktet $min\_distance\_node$ nu er det punkt der i den korteste vej kommer lige inden $child\_node$.\\
Vi søger nu for at vores punkter i $unseen\_nodes$ forsvinder efter vi har arbejdet med dem ved at bruge pop funktionen. Når et punkt har været $min\_distance\_node$ forsvinder den altså fra $unseen\_nodes$, så vi sikrer os at løkken stopper på et tidspunkt. \\
Vi sætter vores nuværende punkt til at være lig med vores mål.
Derefter danner vi en ny while-løkke, som kører så længe at det nuværende punkt ikke er startpunktet. Startpunktet har nemlig ikke en predecessor, og kan dermed ikke beregnes således. I listen $path$ tilføjes nu det nuværende punkt, hvilket vi har sat til at være $\textrm{end}$, på plads $[0]$. Vi kender dermed det sidste punkt i vejen. Derefter defineres $current\_node$ nu til at være punktet lige inden det tidligere $current\_node$ i den korteste vej derhen. Denne tilføjes nu til listen ligeledes på plads $[0]$, og på den måde tilføjes hele vejen i den rigtige rækkefølge. Til sidst indsættes startpunktet.
Hvis den korteste vej til $\textrm{q\_end}$ ikke er uendelig, dvs. hvis vi har fundet den korteste distance hertil, så kan vi beregne den længste vej ved at trække det fra, som vi har har lagt til i kantvægtene for at få ikke-negative vægte og derefter ved at gange med $-1$ for at gå fra den korteste til den længste vej. 
Nu kan vi printe den største profit, da det må være den længste vej igennem grafen. Vi kan også printe vores vej, for at se hvilke punkter vi skal følge og dermed hvor mange gasenheder vi skal købe og sælge de forskellige måneder.
Outputtet for denne funktion er som følger:
\begin{lstlisting} [label=lst:udvidet_output,caption=Output for det basisproblemet.]

The highest profit is 252,72 Euro
The path is ['q0.5', 'q1.8', 'q2.4', 'q3.0', 'q4.2', 'q5.6', 'q6.10', 'q7.6', 'q8.10', 'q9.6', 'q10.10', 'q11.10', 'q12.6', 'q_end'].

\end{lstlisting}
